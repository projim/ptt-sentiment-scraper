<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PTT 八卦版即時負面用詞趨勢儀表板</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns/"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
        }
        .blinking-dot {
            animation: blinker 1.5s linear infinite;
        }
        @keyframes blinker {
            50% {
                opacity: 0;
            }
        }
        input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(1);
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex items-center justify-center min-h-screen p-2 sm:p-4">

    <div class="w-full max-w-5xl bg-gray-800 rounded-2xl shadow-2xl p-4 sm:p-6 md:p-8">
        
        <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4">
            <div>
                <h1 class="text-xl sm:text-2xl md:text-3xl font-bold text-white flex items-center">
                    <span id="connection-dot" class="blinking-dot text-yellow-500 text-4xl mr-2">●</span>
                    <span>PTT 八卦版即時趨勢</span>
                </h1>
                <p class="text-xs sm:text-sm text-gray-400 mt-1">
                    <span id="connection-status">正在連接後端伺服器...</span> | 
                    上次更新: <span id="last-updated">--:--:--</span>
                </p>
            </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <div class="bg-gray-900 p-3 rounded-lg">
                <label for="baseline-date" class="text-sm font-medium text-gray-400">設定基準日</label>
                <input type="date" id="baseline-date" class="w-full bg-gray-700 text-white rounded-md p-2 mt-1 border-0 focus:ring-2 focus:ring-indigo-500">
            </div>
            <div class="bg-gray-900 p-3 rounded-lg">
                <label for="time-unit" class="text-sm font-medium text-gray-400">選擇時間單位</label>
                <select id="time-unit" class="w-full bg-gray-700 text-white rounded-md p-2 mt-1 border-0 focus:ring-2 focus:ring-indigo-500">
                    <option value="realtime">即時 (每分鐘)</option>
                    <option value="hour">每小時 (模擬)</option>
                    <option value="day">每日 (模擬)</option>
                </select>
            </div>
            <div class="bg-gray-900 p-3 rounded-lg">
                 <label class="text-sm font-medium text-gray-400">基準日負面指數 (PNI)</label>
                 <p id="baseline-value" class="text-2xl font-bold text-indigo-400 mt-1">-- %</p>
            </div>
        </div>

        <div class="bg-gray-900 p-4 rounded-xl relative h-64 md:h-96">
            <canvas id="sentimentChart"></canvas>
            <div id="loading-overlay" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center rounded-xl z-10">
                <p id="loading-text" class="text-white text-lg text-center p-4 animate-pulse">正在初始化...</p>
            </div>
        </div>

        <div class="mt-6 bg-gray-900 p-6 rounded-xl">
            <h2 class="text-xl font-bold text-white mb-3">即時趨勢解讀</h2>
            <p id="analysis-text" class="text-gray-300 leading-relaxed">請設定基準日以開始分析。</p>
        </div>
    </div>

    <script>
        const baselineDateEl = document.getElementById('baseline-date');
        const timeUnitEl = document.getElementById('time-unit');
        const baselineValueEl = document.getElementById('baseline-value');
        const analysisText = document.getElementById('analysis-text');
        const lastUpdatedEl = document.getElementById('last-updated');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const connectionDot = document.getElementById('connection-dot');
        const connectionStatus = document.getElementById('connection-status');
        const ctx = document.getElementById('sentimentChart').getContext('2d');
        
        let sentimentChart;
        let baselinePni = 0;
        let ws;
        let isConnected = false;

        const chartConfig = {
            type: 'line',
            data: {
                datasets: [{
                    label: '負面情緒趨勢',
                    data: [],
                    borderColor: 'rgba(255, 255, 255, 0.5)',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.4,
                    fill: true,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: {},
                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                        ticks: { color: 'rgba(255, 255, 255, 0.7)' }
                    },
                    y: {
                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                        ticks: {
                            color: 'rgba(255, 255, 255, 0.7)',
                            callback: value => value.toFixed(0) + '%'
                        },
                        title: {
                            display: true,
                            text: '趨勢 (與基準比較)',
                            color: 'rgba(255, 255, 255, 0.9)'
                        }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: context => `趨勢: ${context.parsed.y.toFixed(1)}%`
                        }
                    },
                    annotation: {
                        annotations: {
                            baseline: {
                                type: 'line',
                                yMin: 0,
                                yMax: 0,
                                borderColor: 'rgba(255, 255, 0, 0.7)',
                                borderWidth: 2,
                                borderDash: [6, 6],
                                label: {
                                    content: '基準線',
                                    enabled: true,
                                    position: 'end',
                                    backgroundColor: 'rgba(255, 255, 0, 0.7)',
                                    color: 'black',
                                    font: { weight: 'bold' }
                                }
                            }
                        }
                    }
                }
            }
        };
        
        function connectWebSocket() {
            // *** 重要：請在部署後將此網址換成您自己的 Render 服務網址 ***
            const WEBSOCKET_URL = "wss://ptt-gossiping-live.onrender.com"; // 範例網址

            ws = new WebSocket(WEBSOCKET_URL);

            ws.onopen = () => {
                isConnected = true;
                console.log("成功連接到 WebSocket 伺服器");
                connectionStatus.textContent = "已連接";
                connectionDot.classList.remove('text-yellow-500', 'text-red-500');
                connectionDot.classList.add('text-green-500');
                if (timeUnitEl.value === 'realtime') {
                    updateChart();
                }
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'pni_update' && timeUnitEl.value === 'realtime' && sentimentChart) {
                    const chartData = sentimentChart.data.datasets[0].data;
                    const trend = data.pni - baselinePni;
                    
                    if (chartData.length >= 60) {
                        chartData.shift();
                    }
                    chartData.push({ x: new Date(data.timestamp * 1000), y: trend });
                    
                    sentimentChart.update('none');
                    lastUpdatedEl.textContent = new Date().toLocaleTimeString('zh-TW');
                    generateAnalysis(chartData, 'realtime');
                }
            };

            ws.onclose = () => {
                console.log("WebSocket 連接已斷開。");
                connectionDot.classList.remove('text-green-500', 'text-yellow-500');
                connectionDot.classList.add('text-red-500');
                
                if (isConnected) {
                    isConnected = false;
                    connectionStatus.textContent = "已斷線，5秒後嘗試重新連接...";
                    setTimeout(connectWebSocket, 5000);
                } else {
                    const errorMsg = `連線失敗。<br><strong class="text-yellow-400">請確認Python後端伺服器已在您的電腦上正確運行並已部署。</strong>`;
                    connectionStatus.innerHTML = errorMsg;
                    loadingText.innerHTML = errorMsg;
                    analysisText.innerHTML = "無法連接到後端伺服器。請部署 Python 爬蟲程式，然後刷新此頁面。";
                }
            };

            ws.onerror = (error) => {
                console.error("WebSocket 發生錯誤:", error);
            };
        }
        
        function generateBaselinePni(dateString) {
            let hash = 0;
            if (!dateString) dateString = new Date().toISOString();
            for (let i = 0; i < dateString.length; i++) {
                const char = dateString.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash |= 0;
            }
            const pseudoRandom = Math.abs(hash / 2147483647);
            return 15 + pseudoRandom * 15;
        }

        function generateHourlyData() {
            const data = [];
            let trend = (Math.random() - 0.5) * 5;
            for (let i = 23; i >= 0; i--) {
                const time = new Date();
                time.setHours(time.getHours() - i);
                trend += (Math.random() - 0.5) * 8;
                if (i > 5 && i < 10) trend += Math.random() * 10;
                trend *= 0.8;
                data.push({ x: time, y: trend });
            }
            return data;
        }

        function generateDailyData() {
            const data = [];
            let trend = (Math.random() - 0.5) * 4;
            for (let i = 29; i >= 0; i--) {
                const time = new Date();
                time.setDate(time.getDate() - i);
                trend += (Math.random() - 0.5) * 5;
                if (time.getDay() === 0 || time.getDay() === 6) trend -= Math.random() * 2;
                if (i > 10 && i < 15) trend += 5;
                trend *= 0.85;
                data.push({ x: time, y: trend });
            }
            return data;
        }

        function generateAnalysis(data, mode) {
            if (!data || data.length === 0) {
                if(mode === 'realtime' && !isConnected) {
                     analysisText.innerHTML = "無法連接到後端伺服器。請部署 Python 爬蟲程式，然後刷新此頁面。";
                } else {
                     analysisText.innerHTML = "等待數據中...";
                }
                return;
            }
            const lastPoint = data[data.length - 1];
            const peakPoint = data.reduce((max, p) => p.y > max.y ? p : max, data[0]);
            
            let analysis = `與基準日 ${baselineDateEl.value} (PNI: ${baselinePni.toFixed(1)}%) 相比，`;
            if (mode === 'realtime') {
                analysis += `過去一小時的即時數據顯示，情緒高峰趨勢為 **${peakPoint.y > 0 ? '+' : ''}${peakPoint.y.toFixed(1)}%**。`;
                analysis += ` 目前最新的趨勢指數為 **${lastPoint.y > 0 ? '+' : ''}${lastPoint.y.toFixed(1)}%**，顯示社群情緒**${Math.abs(lastPoint.y) < 5 ? '相對平靜' : '有明顯波動'}**。`;
            } else { 
                analysis += `在模擬數據中，高峰趨勢為 **${peakPoint.y > 0 ? '+' : ''}${peakPoint.y.toFixed(1)}%**。目前趨勢為 **${lastPoint.y > 0 ? '+' : ''}${lastPoint.y.toFixed(1)}%**。`;
            }
            analysisText.innerHTML = analysis;
        }

        function updateChart() {
            loadingOverlay.style.display = 'flex';
            
            setTimeout(() => {
                const mode = timeUnitEl.value;
                let data;
                
                if (mode === 'realtime') {
                    if (!isConnected) {
                        loadingText.innerHTML = `連線失敗。<br><strong class="text-yellow-400">請確認Python後端伺服器已部署並正確運行。</strong>`;
                        return;
                    }
                    loadingText.textContent = "等待即時數據...";
                    data = []; 
                } else if (mode === 'hour') {
                    loadingText.textContent = "正在生成模擬數據...";
                    data = generateHourlyData();
                } else {
                    loadingText.textContent = "正在生成模擬數據...";
                    data = generateDailyData();
                }

                if (sentimentChart) sentimentChart.destroy();
                
                const newConfig = JSON.parse(JSON.stringify(chartConfig));
                newConfig.data.datasets[0].data = data;
                
                newConfig.data.datasets[0].backgroundColor = (context) => {
                    const {ctx, chartArea, scales} = context.chart;
                    if (!chartArea) return null;
                    const y0 = scales.y.getPixelForValue(0);
                    const gradientFill = ctx.createLinearGradient(0, chartArea.top, 0, chartArea.bottom);
                    const stopPoint = Math.max(0, Math.min(1, y0 / chartArea.bottom));
                    gradientFill.addColorStop(0, 'rgba(239, 68, 68, 0.4)');
                    gradientFill.addColorStop(stopPoint, 'rgba(239, 68, 68, 0)');
                    gradientFill.addColorStop(stopPoint, 'rgba(59, 130, 246, 0)');
                    gradientFill.addColorStop(1, 'rgba(59, 130, 246, 0.4)');
                    return gradientFill;
                };

                const timeFormats = {
                    realtime: { unit: 'minute', tooltipFormat: 'HH:mm:ss', displayFormats: { minute: 'HH:mm' } },
                    hour: { unit: 'hour', tooltipFormat: 'HH:mm', displayFormats: { hour: 'HH:mm' } },
                    day: { unit: 'day', tooltipFormat: 'yyyy/MM/dd', displayFormats: { day: 'MM/dd' } }
                };
                newConfig.options.scales.x.time = timeFormats[mode];
                if(data.length > 0) {
                    newConfig.options.scales.x.time.min = data[0].x;
                    newConfig.options.scales.x.time.max = data[data.length-1].x;
                }

                sentimentChart = new Chart(ctx, newConfig);
                generateAnalysis(data, mode);
                loadingOverlay.style.display = 'none';

            }, 500);
        }

        baselineDateEl.addEventListener('change', () => {
            baselinePni = generateBaselinePni(baselineDateEl.value);
            baselineValueEl.textContent = `${baselinePni.toFixed(1)} %`;
            updateChart();
        });
        timeUnitEl.addEventListener('change', updateChart);

        function initialize() {
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            baselineDateEl.value = yesterday.toISOString().split('T')[0];
            baselinePni = generateBaselinePni(baselineDateEl.value);
            baselineValueEl.textContent = `${baselinePni.toFixed(1)} %`;
            
            connectWebSocket();
        }

        initialize();
    </script>
</body>
</html>
