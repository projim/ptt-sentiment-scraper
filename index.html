<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PTT 八卦版即時負面用詞趨勢儀表板</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/cdn.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
        }
        .blinking-dot {
            animation: blinker 1.5s linear infinite;
        }
        @keyframes blinker {
            50% {
                opacity: 0;
            }
        }
        input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(1);
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex items-center justify-center min-h-screen p-2 sm:p-4">

    <div class="w-full max-w-5xl bg-gray-800 rounded-2xl shadow-2xl p-4 sm:p-6 md:p-8">
        
        <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4">
            <div>
                <h1 class="text-xl sm:text-2xl md:text-3xl font-bold text-white flex items-center">
                    <span id="connection-dot" class="blinking-dot text-yellow-500 text-4xl mr-2">●</span>
                    <span>PTT 八卦版即時趨勢</span>
                </h1>
                <p class="text-xs sm:text-sm text-gray-400 mt-1">
                    <span id="connection-status">正在連接後端伺服器...</span> | 
                    上次更新: <span id="last-updated">--:--:--</span>
                </p>
            </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <div class="bg-gray-900 p-3 rounded-lg">
                <label for="baseline-date" class="text-sm font-medium text-gray-400">設定基準日</label>
                <input type="date" id="baseline-date" class="w-full bg-gray-700 text-white rounded-md p-2 mt-1 border-0 focus:ring-2 focus:ring-indigo-500">
            </div>
            <div class="bg-gray-900 p-3 rounded-lg">
                <label for="time-unit" class="text-sm font-medium text-gray-400">選擇時間單位</label>
                <select id="time-unit" class="w-full bg-gray-700 text-white rounded-md p-2 mt-1 border-0 focus:ring-2 focus:ring-indigo-500">
                    <option value="realtime">每分鐘 (即時)</option>
                    <option value="five_minute">每 5 分鐘 (即時彙總)</option>
                    <option value="hour">每小時 (即時彙總)</option>
                    <option value="day">每日 (即時彙總)</option>
                </select>
            </div>
            <div class="bg-gray-900 p-3 rounded-lg">
                 <label class="text-sm font-medium text-gray-400">基準日負面指數 (PNI)</label>
                 <p id="baseline-value" class="text-2xl font-bold text-indigo-400 mt-1">-- %</p>
            </div>
        </div>

        <div class="bg-gray-900 p-4 rounded-xl relative h-64 md:h-96">
            <canvas id="sentimentChart"></canvas>
            <div id="loading-overlay" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center rounded-xl z-10">
                <p id="loading-text" class="text-white text-lg text-center p-4 animate-pulse">正在初始化...</p>
            </div>
        </div>

        <div class="mt-6 bg-gray-900 p-6 rounded-xl">
            <h2 class="text-xl font-bold text-white mb-3">即時趨勢解讀</h2>
            <p id="analysis-text" class="text-gray-300 leading-relaxed">請設定基準日以開始分析。</p>
        </div>
    </div>

    <script>
        const baselineDateEl = document.getElementById('baseline-date');
        const timeUnitEl = document.getElementById('time-unit');
        const baselineValueEl = document.getElementById('baseline-value');
        const analysisText = document.getElementById('analysis-text');
        const lastUpdatedEl = document.getElementById('last-updated');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const connectionDot = document.getElementById('connection-dot');
        const connectionStatus = document.getElementById('connection-status');
        const ctx = document.getElementById('sentimentChart').getContext('2d');
        
        let sentimentChart;
        let baselinePni = 0;
        let ws;
        let isConnected = false;
        let pniHistory = []; // 用於儲存所有從後端收到的 PNI 數據

        const chartConfig = {
            type: 'line',
            data: {
                datasets: [{
                    label: '負面情緒趨勢',
                    data: [],
                    borderColor: 'rgba(255, 255, 255, 0.5)',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.4,
                    fill: true,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: {},
                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                        ticks: { color: 'rgba(255, 255, 255, 0.7)' }
                    },
                    y: {
                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                        ticks: {
                            color: 'rgba(255, 255, 255, 0.7)',
                            callback: value => value.toFixed(0) + '%'
                        },
                        title: {
                            display: true,
                            text: '趨勢 (與基準比較)',
                            color: 'rgba(255, 255, 255, 0.9)'
                        }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: context => `趨勢: ${context.parsed.y.toFixed(1)}%`
                        }
                    },
                    annotation: {
                        annotations: {
                            baseline: {
                                type: 'line',
                                yMin: 0,
                                yMax: 0,
                                borderColor: 'rgba(255, 255, 0, 0.7)',
                                borderWidth: 2,
                                borderDash: [6, 6],
                                label: {
                                    content: '基準線',
                                    enabled: true,
                                    position: 'end',
                                    backgroundColor: 'rgba(255, 255, 0, 0.7)',
                                    color: 'black',
                                    font: { weight: 'bold' }
                                }
                            }
                        }
                    }
                }
            }
        };
        
        function connectWebSocket() {
            const serviceName = "ptt-gossiping-live"; // 請換成您在 Render 上設定的服務名稱
            const WEBSOCKET_URL = `wss://${serviceName}.onrender.com/ws`;

            ws = new WebSocket(WEBSOCKET_URL);

            ws.onopen = () => {
                isConnected = true;
                console.log("成功連接到 WebSocket 伺服器");
                connectionStatus.textContent = "已連接";
                connectionDot.classList.remove('text-yellow-500', 'text-red-500');
                connectionDot.classList.add('text-green-500');
                updateChart(); 
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'pni_update') {
                    pniHistory.push({
                        timestamp: new Date(data.timestamp * 1000),
                        pni: data.pni
                    });
                    
                    const thirtyDaysAgo = dateFns.subDays(new Date(), 30);
                    pniHistory = pniHistory.filter(p => p.timestamp >= thirtyDaysAgo);

                    updateActiveChart();
                }
            };

            ws.onclose = () => {
                console.log("WebSocket 連接已斷開。");
                connectionDot.classList.remove('text-green-500', 'text-yellow-500');
                connectionDot.classList.add('text-red-500');
                
                if (isConnected) {
                    isConnected = false;
                    connectionStatus.textContent = "已斷線，5秒後嘗試重新連接...";
                    setTimeout(connectWebSocket, 5000);
                } else {
                    const errorMsg = `連線失敗。<br><strong class="text-yellow-400">請確認Python後端伺服器已部署並正確運行。</strong>`;
                    connectionStatus.innerHTML = errorMsg;
                    loadingText.innerHTML = errorMsg;
                    analysisText.innerHTML = "無法連接到後端伺服器。請部署 Python 爬蟲程式，然後刷新此頁面。";
                }
            };

            ws.onerror = (error) => {
                console.error("WebSocket 發生錯誤:", error);
            };
        }
        
        function updateActiveChart() {
            if (!sentimentChart || !isConnected) return;

            const mode = timeUnitEl.value;
            let dataForChart = [];

            if (mode === 'realtime') {
                dataForChart = processRealtimeData(pniHistory);
            } else if (mode === 'five_minute') {
                dataForChart = processFiveMinuteData(pniHistory);
            } else if (mode === 'hour') {
                dataForChart = processHourlyData(pniHistory);
            } else if (mode === 'day') {
                dataForChart = processDailyData(pniHistory);
            }
            
            sentimentChart.data.datasets[0].data = dataForChart;
            sentimentChart.update('none');
            lastUpdatedEl.textContent = new Date().toLocaleTimeString('zh-TW');
            generateAnalysis(dataForChart, mode);
        }

        function processRealtimeData(history) {
            const recentHistory = history.slice(-60);
            return recentHistory.map(p => ({
                x: p.timestamp,
                y: p.pni - baselinePni
            }));
        }

        function processFiveMinuteData(history) {
            const sixHoursAgo = dateFns.subHours(new Date(), 6);
            const recentHistory = history.filter(p => p.timestamp >= sixHoursAgo);

            const fiveMinuteBuckets = recentHistory.reduce((buckets, p) => {
                const minutes = p.timestamp.getMinutes();
                const bucketStartMinutes = Math.floor(minutes / 5) * 5;
                const bucketTimestamp = dateFns.setMinutes(dateFns.startOfHour(p.timestamp), bucketStartMinutes);
                const bucketKey = bucketTimestamp.toISOString();

                if (!buckets[bucketKey]) {
                    buckets[bucketKey] = { sum: 0, count: 0, timestamp: bucketTimestamp };
                }
                buckets[bucketKey].sum += p.pni;
                buckets[bucketKey].count++;
                return buckets;
            }, {});

            return Object.values(fiveMinuteBuckets).map(({ timestamp, sum, count }) => ({
                x: timestamp,
                y: (sum / count) - baselinePni
            })).sort((a, b) => a.x - b.x);
        }

        function processHourlyData(history) {
            const twentyFourHoursAgo = dateFns.subHours(new Date(), 24);
            const recentHistory = history.filter(p => p.timestamp >= twentyFourHoursAgo);

            const hourlyBuckets = recentHistory.reduce((buckets, p) => {
                const hourKey = dateFns.format(p.timestamp, 'yyyy-MM-dd HH:00:00');
                if (!buckets[hourKey]) {
                    buckets[hourKey] = { sum: 0, count: 0 };
                }
                buckets[hourKey].sum += p.pni;
                buckets[hourKey].count++;
                return buckets;
            }, {});

            return Object.entries(hourlyBuckets).map(([hourKey, { sum, count }]) => ({
                x: new Date(hourKey),
                y: (sum / count) - baselinePni
            }));
        }

        function processDailyData(history) {
            const thirtyDaysAgo = dateFns.subDays(new Date(), 30);
            const recentHistory = history.filter(p => p.timestamp >= thirtyDaysAgo);

            const dailyBuckets = recentHistory.reduce((buckets, p) => {
                const dayKey = dateFns.format(p.timestamp, 'yyyy-MM-dd');
                if (!buckets[dayKey]) {
                    buckets[dayKey] = { sum: 0, count: 0 };
                }
                buckets[dayKey].sum += p.pni;
                buckets[dayKey].count++;
                return buckets;
            }, {});

            return Object.entries(dailyBuckets).map(([dayKey, { sum, count }]) => ({
                x: dateFns.startOfDay(new Date(dayKey)),
                y: (sum / count) - baselinePni
            }));
        }

        function generateAnalysis(data, mode) {
            if (!data || data.length === 0) {
                if(!isConnected) {
                     analysisText.innerHTML = "無法連接到後端伺服器。請部署 Python 爬蟲程式，然後刷新此頁面。";
                } else {
                     analysisText.innerHTML = "正在等待從後端接收即時數據...";
                }
                return;
            }
            const lastPoint = data[data.length - 1];
            const peakPoint = data.reduce((max, p) => p.y > max.y ? p : max, data[0]);
            
            let analysis = `與基準日 ${baselineDateEl.value} (PNI: ${baselinePni.toFixed(1)}%) 相比，`;
            if (mode === 'realtime') {
                analysis += `最近一小時的即時數據顯示，情緒高峰趨勢為 **${peakPoint.y > 0 ? '+' : ''}${peakPoint.y.toFixed(1)}%**。`;
            } else if (mode === 'five_minute') {
                analysis += `過去6小時的彙總數據顯示，情緒高峰出現在 **${dateFns.format(peakPoint.x, 'HH:mm')}** 左右，高出基準 **${peakPoint.y.toFixed(1)}%**。`;
            } else if (mode === 'hour') {
                analysis += `過去24小時的彙總數據顯示，情緒高峰出現在 **${dateFns.format(peakPoint.x, 'HH:00')}** 左右，高出基準 **${peakPoint.y.toFixed(1)}%**。`;
            } else {
                analysis += `過去30天的彙總數據顯示，情緒高峰出現在 **${dateFns.format(peakPoint.x, 'MM/dd')}**，高出基準 **${peakPoint.y.toFixed(1)}%**。`;
            }
            analysis += ` 目前最新的趨勢指數為 **${lastPoint.y > 0 ? '+' : ''}${lastPoint.y.toFixed(1)}%**。`;
            analysisText.innerHTML = analysis;
        }

        function updateChart() {
            loadingOverlay.style.display = 'flex';
            
            setTimeout(() => {
                const mode = timeUnitEl.value;
                if (!isConnected && mode === 'realtime') {
                    loadingText.innerHTML = `連線失敗。<br><strong class="text-yellow-400">請確認Python後端伺服器已部署並正確運行。</strong>`;
                    return;
                }
                loadingText.textContent = "等待即時數據...";

                if (sentimentChart) sentimentChart.destroy();
                
                const newConfig = JSON.parse(JSON.stringify(chartConfig));
                const timeFormats = {
                    realtime: { unit: 'minute', tooltipFormat: 'HH:mm:ss', displayFormats: { minute: 'HH:mm' } },
                    five_minute: { unit: 'minute', tooltipFormat: 'HH:mm', displayFormats: { minute: 'HH:mm' } },
                    hour: { unit: 'hour', tooltipFormat: 'yyyy/MM/dd HH:mm', displayFormats: { hour: 'HH:mm' } },
                    day: { unit: 'day', tooltipFormat: 'yyyy/MM/dd', displayFormats: { day: 'MM/dd' } }
                };
                newConfig.options.scales.x.time = timeFormats[mode];
                
                sentimentChart = new Chart(ctx, newConfig);
                updateActiveChart(); 
                loadingOverlay.style.display = 'none';

            }, 500);
        }
        
        function generateBaselinePni(dateString) {
            let hash = 0;
            if (!dateString) dateString = new Date().toISOString();
            for (let i = 0; i < dateString.length; i++) {
                const char = dateString.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash |= 0;
            }
            const pseudoRandom = Math.abs(hash / 2147483647);
            return 15 + pseudoRandom * 15;
        }

        baselineDateEl.addEventListener('change', () => {
            baselinePni = generateBaselinePni(baselineDateEl.value);
            baselineValueEl.textContent = `${baselinePni.toFixed(1)} %`;
            updateChart();
        });
        timeUnitEl.addEventListener('change', updateChart);

        function initialize() {
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            baselineDateEl.value = yesterday.toISOString().split('T')[0];
            baselinePni = generateBaselinePni(baselineDateEl.value);
            baselineValueEl.textContent = `${baselinePni.toFixed(1)} %`;
            
            connectWebSocket();
        }

        initialize();
    </script>
</body>
</html>
