<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PTT 八卦版輿情分析平台</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', 'Noto Sans TC', sans-serif; }
        .blinking-dot { animation: blinker 1.5s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }
        input[type="date"]::-webkit-calendar-picker-indicator { filter: invert(1); cursor: pointer; }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex items-center justify-center min-h-screen p-2 sm:p-4">

    <div class="w-full max-w-5xl bg-gray-800 rounded-2xl shadow-2xl p-4 sm:p-6 md:p-8">
        
        <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4">
            <div>
                <h1 class="text-xl sm:text-2xl md:text-3xl font-bold text-white flex items-center">
                    <span id="connection-dot" class="blinking-dot text-yellow-500 text-4xl mr-2">●</span>
                    <span>PTT 八卦版輿情分析平台</span>
                </h1>
                <p class="text-xs sm:text-sm text-gray-400 mt-1">
                    <span id="connection-status">正在初始化...</span> | 
                    上次更新: <span id="last-updated">--:--:--</span>
                </p>
            </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <div class="bg-gray-900 p-3 rounded-lg">
                <label for="baseline-date" class="text-sm font-medium text-gray-400">設定基準日</label>
                <input type="date" id="baseline-date" class="w-full bg-gray-700 text-white rounded-md p-2 mt-1 border-0 focus:ring-2 focus:ring-indigo-500">
            </div>
            <div class="bg-gray-900 p-3 rounded-lg">
                <label for="time-unit" class="text-sm font-medium text-gray-400">選擇時間維度</label>
                <select id="time-unit" class="w-full bg-gray-700 text-white rounded-md p-2 mt-1 border-0 focus:ring-2 focus:ring-indigo-500">
                    <option value="1m">每分鐘 (即時)</option>
                    <option value="5m">每 5 分鐘 (彙總)</option>
                    <option value="30m">每 30 分鐘 (彙總)</option>
                    <option value="1h">每小時 (彙總)</option>
                </select>
            </div>
            <div class="bg-gray-900 p-3 rounded-lg">
                 <label class="text-sm font-medium text-gray-400">基準日負面指數 (PNI)</label>
                 <p id="baseline-value" class="text-2xl font-bold text-indigo-400 mt-1">-- %</p>
            </div>
        </div>

        <div class="bg-gray-900 p-4 rounded-xl relative h-64 md:h-96">
            <canvas id="sentimentChart"></canvas>
            <div id="loading-overlay" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center rounded-xl z-10">
                <p id="loading-text" class="text-white text-lg text-center p-4 animate-pulse">等待應用程式啟動...</p>
            </div>
        </div>

        <div class="mt-6 bg-gray-900 p-6 rounded-xl">
            <h2 class="text-xl font-bold text-white mb-3">趨勢解讀</h2>
            <p id="analysis-text" class="text-gray-300 leading-relaxed">請設定基準日以開始分析。</p>
        </div>
    </div>

    <!-- [FINAL FIX] 從本地路徑載入函式庫，確保 100% 成功 -->
    <script src="./libs/chart.min.js"></script>
    <script src="./libs/date-fns.min.js"></script>
    <script src="./libs/chartjs-adapter-date-fns.bundle.min.js"></script>

    <script>
    // 主應用程式邏輯
    document.addEventListener('DOMContentLoaded', () => {
        // 現在我們可以安全地假設函式庫已存在
        const { format, setMinutes, startOfHour, subDays, subHours } = window.dateFns;

        const baselineDateEl = document.getElementById('baseline-date');
        const timeUnitEl = document.getElementById('time-unit');
        const baselineValueEl = document.getElementById('baseline-value');
        const analysisText = document.getElementById('analysis-text');
        const lastUpdatedEl = document.getElementById('last-updated');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const connectionDot = document.getElementById('connection-dot');
        const connectionStatus = document.getElementById('connection-status');
        const ctx = document.getElementById('sentimentChart').getContext('2d');
        
        let sentimentChart;
        let baselinePni = 0;
        let ws;
        let isConnected = false;
        let pniHistory = [];

        const serviceName = "ptt-gossiping-live"; // 請換成您在 Render 上設定的服務名稱
        const WEBSOCKET_URL = `wss://${serviceName}.onrender.com/ws`;
        
        const chartConfig = {
            type: 'line',
            data: {
                datasets: [{
                    label: '負面情緒趨勢',
                    data: [],
                    borderColor: 'rgba(255, 255, 255, 0.5)',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.4,
                    fill: true,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: {},
                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                        ticks: { color: 'rgba(255, 255, 255, 0.7)' }
                    },
                    y: {
                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                        ticks: {
                            color: 'rgba(255, 255, 255, 0.7)',
                            callback: value => value.toFixed(0) + '%'
                        },
                        title: {
                            display: true,
                            text: '趨勢 (與基準比較)',
                            color: 'rgba(255, 255, 255, 0.9)'
                        }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: context => `趨勢: ${context.parsed.y.toFixed(1)}%`
                        }
                    },
                    annotation: {
                        annotations: {
                            baseline: {
                                type: 'line',
                                yMin: 0,
                                yMax: 0,
                                borderColor: 'rgba(255, 255, 0, 0.7)',
                                borderWidth: 2,
                                borderDash: [6, 6],
                                label: {
                                    content: '基準線',
                                    enabled: true,
                                    position: 'end',
                                    backgroundColor: 'rgba(255, 255, 0, 0.7)',
                                    color: 'black',
                                    font: { weight: 'bold' }
                                }
                            }
                        }
                    }
                }
            }
        };

        function connectWebSocket() {
            ws = new WebSocket(WEBSOCKET_URL);

            ws.onopen = () => {
                isConnected = true;
                connectionStatus.textContent = "已連接";
                connectionDot.classList.remove('text-yellow-500', 'text-red-500');
                connectionDot.classList.add('text-green-500');
                updateChart(); 
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'pni_update') {
                    const newPoint = { timestamp: new Date(data.timestamp * 1000), pni: data.pni };
                    pniHistory.push(newPoint);
                    
                    const thirtyDaysAgo = subDays(new Date(), 30);
                    pniHistory = pniHistory.filter(p => p.timestamp >= thirtyDaysAgo);

                    updateChart();
                    lastUpdatedEl.textContent = new Date().toLocaleTimeString('zh-TW');
                }
            };
            
            ws.onclose = () => {
                console.log("WebSocket 連接已斷開。");
                connectionDot.classList.remove('text-green-500', 'text-yellow-500');
                connectionDot.classList.add('text-red-500');
                if (isConnected) {
                    isConnected = false;
                    connectionStatus.textContent = "已斷線，5秒後嘗試重新連接...";
                    setTimeout(connectWebSocket, 5000);
                } else {
                    const errorMsg = `連線失敗。<br><strong class="text-yellow-400">請確認Python後端伺服器已部署並正確運行。</strong>`;
                    connectionStatus.innerHTML = errorMsg;
                    loadingText.innerHTML = errorMsg;
                    analysisText.innerHTML = "無法連接到後端伺服器。請部署 Python 爬蟲程式，然後刷新此頁面。";
                }
            };

            ws.onerror = (error) => {
                console.error("WebSocket 發生錯誤:", error);
            };
        }
        
        function aggregateData(history, timescale) {
            if (!history || history.length === 0) return [];

            let filteredHistory = history;
            let bucketSize = 1; // in minutes
            if (timescale === '5m') {
                filteredHistory = history.filter(p => p.timestamp >= subHours(new Date(), 6));
                bucketSize = 5;
            } else if (timescale === '30m') {
                filteredHistory = history.filter(p => p.timestamp >= subHours(new Date(), 24));
                bucketSize = 30;
            } else if (timescale === '1h') {
                filteredHistory = history.filter(p => p.timestamp >= subDays(new Date(), 3));
                bucketSize = 60;
            } else { // '1m' or realtime
                return history.slice(-60).map(p => ({ x: p.timestamp, y: p.pni - baselinePni }));
            }

            const getBucketKey = (ts) => {
                const date = new Date(ts);
                const totalMinutes = date.getHours() * 60 + date.getMinutes();
                const bucketMinutes = Math.floor(totalMinutes / bucketSize) * bucketSize;
                const hour = Math.floor(bucketMinutes / 60);
                const minute = bucketMinutes % 60;
                return format(setMinutes(startOfHour(date), minute), "yyyy-MM-dd'T'HH:mm:ss");
            };

            const buckets = filteredHistory.reduce((acc, record) => {
                const key = getBucketKey(record.timestamp);
                if (!acc[key]) acc[key] = [];
                acc[key].push(record.pni);
                return acc;
            }, {});

            return Object.entries(buckets).map(([key, pnis]) => {
                const avgPni = pnis.reduce((a, b) => a + b, 0) / pnis.length;
                return { x: new Date(key), y: avgPni - baselinePni };
            }).sort((a,b) => a.x - b.x);
        }

        function initializeChartConfig(mode) {
            const newConfig = JSON.parse(JSON.stringify(chartConfig));
            const timeFormats = {
                '1m': { unit: 'minute', tooltipFormat: 'HH:mm', displayFormats: { minute: 'HH:mm' } },
                '5m': { unit: 'minute', tooltipFormat: 'HH:mm', displayFormats: { minute: 'HH:mm' } },
                '30m': { unit: 'minute', tooltipFormat: 'HH:mm', displayFormats: { minute: 'HH:mm' } },
                '1h': { unit: 'hour', tooltipFormat: 'MM/dd HH:mm', displayFormats: { hour: 'HH:00' } }
            };
            newConfig.options.scales.x.time = timeFormats[mode];
            return newConfig;
        }

        function updateChart() {
            const mode = timeUnitEl.value;
            
            loadingOverlay.style.display = 'flex';
            loadingText.textContent = "正在彙總即時數據...";

            setTimeout(() => {
                const dataForChart = aggregateData(pniHistory, mode);
                
                if (sentimentChart) {
                    sentimentChart.destroy();
                }
                const newConfig = initializeChartConfig(mode);
                sentimentChart = new Chart(ctx, newConfig);
                
                sentimentChart.data.datasets[0].data = dataForChart;
                sentimentChart.update();
                generateAnalysis(dataForChart, mode);
                loadingOverlay.style.display = 'none';
            }, 100);
        }
        
        function generateAnalysis(data, mode) {
             if (!isConnected) {
                analysisText.innerHTML = "無法連接到後端伺服器。請部署 Python 爬蟲程式，然後刷新此頁面。";
                return;
            }
            if (!data || data.length === 0) {
                analysisText.innerHTML = "正在等待從後端接收即時數據...";
                return;
            }
            const lastPoint = data[data.length - 1];
            const peakPoint = data.reduce((max, p) => p.y > max.y ? p : max, data[0]);
            
            let analysis = `與基準日 ${baselineDateEl.value} (PNI: ${baselinePni.toFixed(1)}%) 相比，`;
            const timeRanges = {
                '1m': '最近一小時',
                '5m': '過去6小時',
                '30m': '過去24小時',
                '1h': '過去3天'
            };
            analysis += `${timeRanges[mode]}的數據顯示，情緒高峰趨勢為 **${peakPoint.y > 0 ? '+' : ''}${peakPoint.y.toFixed(1)}%**。`;
            analysis += ` 目前最新的趨勢指數為 **${lastPoint.y > 0 ? '+' : ''}${lastPoint.y.toFixed(1)}%**。`;
            analysisText.innerHTML = analysis;
        }

        function generateBaselinePni(dateString) {
            let hash = 0;
            if (!dateString) dateString = new Date().toISOString();
            for (let i = 0; i < dateString.length; i++) {
                const char = dateString.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash |= 0;
            }
            const pseudoRandom = Math.abs(hash / 2147483647);
            return 15 + pseudoRandom * 15;
        }

        baselineDateEl.addEventListener('change', () => {
            baselinePni = generateBaselinePni(baselineDateEl.value);
            baselineValueEl.textContent = `${baselinePni.toFixed(1)} %`;
            updateChart();
        });
        timeUnitEl.addEventListener('change', updateChart);

        function initialize() {
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            baselineDateEl.value = yesterday.toISOString().split('T')[0];
            baselinePni = generateBaselinePni(baselineDateEl.value);
            baselineValueEl.textContent = `${baselinePni.toFixed(1)} %`;
            
            connectWebSocket();
        }

        initialize();
    });
    </script>
</body>
</html>
