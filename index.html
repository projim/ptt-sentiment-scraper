<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PTT 八卦版輿情分析平台</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- [FIX] 更換為 unpkg.com CDN 並加上 defer 屬性 -->
    <script src="https://unpkg.com/chart.js@3.9.1/dist/chart.min.js" defer></script>
    <script src="https://unpkg.com/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js" defer></script>
    <script src="https://unpkg.com/date-fns@2.29.3/cdn.min.js" defer></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', 'Noto Sans TC', sans-serif; }
        .blinking-dot { animation: blinker 1.5s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }
        input[type="date"]::-webkit-calendar-picker-indicator { filter: invert(1); cursor: pointer; }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex items-center justify-center min-h-screen p-2 sm:p-4">

    <div class="w-full max-w-5xl bg-gray-800 rounded-2xl shadow-2xl p-4 sm:p-6 md:p-8">
        
        <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4">
            <div>
                <h1 class="text-xl sm:text-2xl md:text-3xl font-bold text-white flex items-center">
                    <span id="connection-dot" class="blinking-dot text-yellow-500 text-4xl mr-2">●</span>
                    <span>PTT 八卦版輿情分析平台</span>
                </h1>
                <p class="text-xs sm:text-sm text-gray-400 mt-1">
                    <span id="connection-status">正在連接後端伺服器...</span> | 
                    上次更新: <span id="last-updated">--:--:--</span>
                </p>
            </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <div class="bg-gray-900 p-3 rounded-lg">
                <label for="baseline-date" class="text-sm font-medium text-gray-400">設定基準日</label>
                <input type="date" id="baseline-date" class="w-full bg-gray-700 text-white rounded-md p-2 mt-1 border-0 focus:ring-2 focus:ring-indigo-500">
            </div>
            <div class="bg-gray-900 p-3 rounded-lg">
                <label for="time-unit" class="text-sm font-medium text-gray-400">選擇時間維度</label>
                <select id="time-unit" class="w-full bg-gray-700 text-white rounded-md p-2 mt-1 border-0 focus:ring-2 focus:ring-indigo-500">
                    <option value="realtime">即時 (最近一小時)</option>
                    <option value="30m">每 30 分鐘 (過去一天)</option>
                    <option value="1h">每小時 (過去三天)</option>
                </select>
            </div>
            <div class="bg-gray-900 p-3 rounded-lg">
                 <label class="text-sm font-medium text-gray-400">基準日負面指數 (PNI)</label>
                 <p id="baseline-value" class="text-2xl font-bold text-indigo-400 mt-1">-- %</p>
            </div>
        </div>

        <div class="bg-gray-900 p-4 rounded-xl relative h-64 md:h-96">
            <canvas id="sentimentChart"></canvas>
            <div id="loading-overlay" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center rounded-xl z-10">
                <p id="loading-text" class="text-white text-lg text-center p-4 animate-pulse">正在初始化...</p>
            </div>
        </div>

        <div class="mt-6 bg-gray-900 p-6 rounded-xl">
            <h2 class="text-xl font-bold text-white mb-3">趨勢解讀</h2>
            <p id="analysis-text" class="text-gray-300 leading-relaxed">請設定基準日以開始分析。</p>
        </div>
    </div>

    <script>
    function mainApp() {
        const { format, setMinutes, startOfHour } = window.dateFns;

        const baselineDateEl = document.getElementById('baseline-date');
        const timeUnitEl = document.getElementById('time-unit');
        const baselineValueEl = document.getElementById('baseline-value');
        const analysisText = document.getElementById('analysis-text');
        const lastUpdatedEl = document.getElementById('last-updated');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const connectionDot = document.getElementById('connection-dot');
        const connectionStatus = document.getElementById('connection-status');
        const ctx = document.getElementById('sentimentChart').getContext('2d');
        
        let sentimentChart;
        let baselinePni = 0;
        let ws;
        let isConnected = false;
        let realtimePniHistory = [];

        const serviceName = "ptt-gossiping-live"; // 請換成您在 Render 上設定的服務名稱
        const API_BASE_URL = `https://${serviceName}.onrender.com`;
        const WEBSOCKET_URL = `wss://${serviceName}.onrender.com/ws`;
        
        const chartConfig = {
            type: 'line',
            data: {
                datasets: [{
                    label: '負面情緒趨勢',
                    data: [],
                    borderColor: 'rgba(255, 255, 255, 0.5)',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.4,
                    fill: true,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: {},
                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                        ticks: { color: 'rgba(255, 255, 255, 0.7)' }
                    },
                    y: {
                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                        ticks: {
                            color: 'rgba(255, 255, 255, 0.7)',
                            callback: value => value.toFixed(0) + '%'
                        },
                        title: {
                            display: true,
                            text: '趨勢 (與基準比較)',
                            color: 'rgba(255, 255, 255, 0.9)'
                        }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: context => `趨勢: ${context.parsed.y.toFixed(1)}%`
                        }
                    },
                    annotation: {
                        annotations: {
                            baseline: {
                                type: 'line',
                                yMin: 0,
                                yMax: 0,
                                borderColor: 'rgba(255, 255, 0, 0.7)',
                                borderWidth: 2,
                                borderDash: [6, 6],
                                label: {
                                    content: '基準線',
                                    enabled: true,
                                    position: 'end',
                                    backgroundColor: 'rgba(255, 255, 0, 0.7)',
                                    color: 'black',
                                    font: { weight: 'bold' }
                                }
                            }
                        }
                    }
                }
            }
        };

        function connectWebSocket() {
            ws = new WebSocket(WEBSOCKET_URL);

            ws.onopen = () => {
                isConnected = true;
                connectionStatus.textContent = "已連接";
                connectionDot.classList.remove('text-yellow-500', 'text-red-500');
                connectionDot.classList.add('text-green-500');
                updateChart(); 
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'pni_update') {
                    const newPoint = { timestamp: new Date(data.timestamp * 1000), pni: data.pni };
                    realtimePniHistory.push(newPoint);
                    if (realtimePniHistory.length > 60) realtimePniHistory.shift();

                    if (timeUnitEl.value === 'realtime') {
                        updateActiveChart();
                    }
                    lastUpdatedEl.textContent = new Date().toLocaleTimeString('zh-TW');
                }
            };
            
            ws.onclose = () => {
                console.log("WebSocket 連接已斷開。");
                connectionDot.classList.remove('text-green-500', 'text-yellow-500');
                connectionDot.classList.add('text-red-500');
                if (isConnected) {
                    isConnected = false;
                    connectionStatus.textContent = "已斷線，5秒後嘗試重新連接...";
                    setTimeout(connectWebSocket, 5000);
                } else {
                    const errorMsg = `連線失敗。<br><strong class="text-yellow-400">請確認Python後端伺服器已部署並正確運行。</strong>`;
                    connectionStatus.innerHTML = errorMsg;
                    loadingText.innerHTML = errorMsg;
                    analysisText.innerHTML = "無法連接到後端伺服器。請部署 Python 爬蟲程式，然後刷新此頁面。";
                }
            };

            ws.onerror = (error) => {
                console.error("WebSocket 發生錯誤:", error);
            };
        }

        function updateActiveChart() {
            if (!sentimentChart) return;
            const dataForChart = realtimePniHistory.map(p => ({ x: p.timestamp, y: p.pni - baselinePni }));
            sentimentChart.data.datasets[0].data = dataForChart;
            sentimentChart.update('none');
            generateAnalysis(dataForChart, 'realtime');
        }

        async function fetchAndProcessHistory(timescale) {
            loadingOverlay.style.display = 'flex';
            loadingText.textContent = `正在從資料庫獲取 ${timescale} 歷史數據...`;
            try {
                const response = await fetch(`${API_BASE_URL}/api/history?timescale=${timescale}`);
                if (!response.ok) throw new Error('Network response was not ok');
                const history = await response.json();
                
                const dataForChart = aggregateData(history, timescale);
                
                if (sentimentChart) sentimentChart.destroy();
                const newConfig = initializeChartConfig(timescale);
                sentimentChart = new Chart(ctx, newConfig);
                
                sentimentChart.data.datasets[0].data = dataForChart;
                sentimentChart.update();
                generateAnalysis(dataForChart, timescale);

            } catch (error) {
                console.error('獲取歷史數據失敗:', error);
                analysisText.innerHTML = "無法從資料庫獲取歷史數據。請稍後再試。錯誤：" + error.message;
            } finally {
                loadingOverlay.style.display = 'none';
            }
        }
        
        function aggregateData(history, timescale) {
            if (!history || history.length === 0) return [];

            const getBucketKey = (ts, scale) => {
                const date = new Date(ts);
                if (scale === '30m') {
                    const minutes = Math.floor(date.getMinutes() / 30) * 30;
                    return format(setMinutes(startOfHour(date), minutes), "yyyy-MM-dd'T'HH:mm:ss");
                }
                if (scale === '1h') {
                    return format(startOfHour(date), "yyyy-MM-dd'T'HH:mm:ss");
                }
                return '';
            };

            const buckets = history.reduce((acc, record) => {
                const key = getBucketKey(record.timestamp, timescale);
                if (!acc[key]) acc[key] = [];
                acc[key].push(record.pni);
                return acc;
            }, {});

            return Object.entries(buckets).map(([key, pnis]) => {
                const avgPni = pnis.reduce((a, b) => a + b, 0) / pnis.length;
                return { x: new Date(key), y: avgPni - baselinePni };
            }).sort((a,b) => a.x - b.x);
        }

        function initializeChartConfig(mode) {
            const newConfig = JSON.parse(JSON.stringify(chartConfig));
            const timeFormats = {
                realtime: { unit: 'minute', tooltipFormat: 'HH:mm:ss', displayFormats: { minute: 'HH:mm' } },
                '30m': { unit: 'minute', tooltipFormat: 'HH:mm', displayFormats: { minute: 'HH:mm' } },
                '1h': { unit: 'hour', tooltipFormat: 'yyyy/MM/dd HH:mm', displayFormats: { hour: 'HH:mm' } }
            };
            newConfig.options.scales.x.time = timeFormats[mode];
            return newConfig;
        }

        function updateChart() {
            const mode = timeUnitEl.value;
            if (mode === 'realtime') {
                loadingOverlay.style.display = 'flex';
                loadingText.textContent = "等待即時數據...";
                if (sentimentChart) sentimentChart.destroy();
                const newConfig = initializeChartConfig(mode);
                sentimentChart = new Chart(ctx, newConfig);
                updateActiveChart();
                loadingOverlay.style.display = 'none';
            } else {
                fetchAndProcessHistory(mode);
            }
        }
        
        function generateAnalysis(data, mode) {
            if (!data || data.length === 0) {
                if(!isConnected) {
                     analysisText.innerHTML = "無法連接到後端伺服器。請部署 Python 爬蟲程式，然後刷新此頁面。";
                } else {
                     analysisText.innerHTML = "正在等待從後端接收即時數據...";
                }
                return;
            }
            const lastPoint = data[data.length - 1];
            const peakPoint = data.reduce((max, p) => p.y > max.y ? p : max, data[0]);
            
            let analysis = `與基準日 ${baselineDateEl.value} (PNI: ${baselinePni.toFixed(1)}%) 相比，`;
            if (mode === 'realtime') {
                analysis += `最近一小時的即時數據顯示，情緒高峰趨勢為 **${peakPoint.y > 0 ? '+' : ''}${peakPoint.y.toFixed(1)}%**。`;
            } else if (mode === '30m') {
                analysis += `過去24小時的彙總數據顯示，情緒高峰出現在 **${format(peakPoint.x, 'HH:mm')}** 左右，高出基準 **${peakPoint.y.toFixed(1)}%**。`;
            } else { // '1h'
                analysis += `過去3天的彙總數據顯示，情緒高峰出現在 **${format(peakPoint.x, 'MM/dd HH:00')}**，高出基準 **${peakPoint.y.toFixed(1)}%**。`;
            }
            analysis += ` 目前最新的趨勢指數為 **${lastPoint.y > 0 ? '+' : ''}${lastPoint.y.toFixed(1)}%**。`;
            analysisText.innerHTML = analysis;
        }

        function generateBaselinePni(dateString) {
            let hash = 0;
            if (!dateString) dateString = new Date().toISOString();
            for (let i = 0; i < dateString.length; i++) {
                const char = dateString.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash |= 0;
            }
            const pseudoRandom = Math.abs(hash / 2147483647);
            return 15 + pseudoRandom * 15;
        }

        baselineDateEl.addEventListener('change', () => {
            baselinePni = generateBaselinePni(baselineDateEl.value);
            baselineValueEl.textContent = `${baselinePni.toFixed(1)} %`;
            updateChart();
        });
        timeUnitEl.addEventListener('change', updateChart);

        function initialize() {
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            baselineDateEl.value = yesterday.toISOString().split('T')[0];
            baselinePni = generateBaselinePni(baselineDateEl.value);
            baselineValueEl.textContent = `${baselinePni.toFixed(1)} %`;
            
            connectWebSocket();
        }

        initialize();
    }

    function checkAndRun() {
        let attempts = 0;
        const maxAttempts = 100; // Try for 10 seconds
        const intervalId = setInterval(() => {
            if (window.Chart && window.dateFns && typeof window.dateFns.format === 'function') {
                clearInterval(intervalId);
                console.log("所有函式庫已成功載入，正在啟動應用程式...");
                mainApp();
            } else {
                attempts++;
                if (attempts > maxAttempts) {
                    clearInterval(intervalId);
                    console.error("Fatal Error: A required library (Chart.js or date-fns) failed to load after 10 seconds.");
                    document.getElementById('loading-text').innerHTML = "關鍵函式庫載入超時，請檢查網路連線並刷新頁面。";
                }
            }
        }, 100);
    }

    // [FIX] 使用 DOMContentLoaded，並配合 script 標籤的 defer 屬性，這是最穩健的作法
    document.addEventListener('DOMContentLoaded', checkAndRun);

    </script>
</body>
</html>
